import { Ft as onMounted, Jt as renderSlot, K as createCommentVNode, Kn as ref, Vt as openBlock, Wn as reactive, dn as useSlots, gn as watch, nr as unref, nt as defineComponent, q as createElementBlock } from "./vue.runtime.esm-bundler-C-fpSPyj.js";

//#region node_modules/vue3-google-login/dist/index.esm.js
var u = Object.freeze({ __proto__: null });
var s = {
	library: "https://accounts.google.com/gsi/client",
	defaultButtonConfig: {
		theme: "outline",
		size: "large"
	},
	scopes: "email profile openid",
	ssrError: "vue3-google-login cannot be executed on the server side. See here for more info https://devbaji.github.io/vue3-google-login/#no-ssr-support"
};
var g = reactive({
	clientId: null,
	popupType: "CODE",
	prompt: !1,
	autoLogin: !1,
	idConfiguration: null,
	buttonConfig: s.defaultButtonConfig,
	callback: () => {},
	error: null
}), f = reactive({
	apiLoaded: !1,
	apiLoadIntitited: !1
}), b = (e) => {
	try {
		const t = e.split(".")[1].replace(/-/g, "+").replace(/_/g, "/"), o = decodeURIComponent(atob(t).split("").map((function(e$1) {
			return "%" + ("00" + e$1.charCodeAt(0).toString(16)).slice(-2);
		})).join(""));
		return JSON.parse(o);
	} catch (e$1) {
		throw "JWT provided is invalid";
	}
}, h = () => new Promise(((e, t) => {
	if ("undefined" != typeof window) {
		if (!f.apiLoadIntitited) {
			const o = document.createElement("script");
			f.apiLoadIntitited = !0, o.addEventListener("load", (() => {
				f.apiLoaded = !0, e(window.google);
			})), o.addEventListener("error", (() => {
				t("Failed to load the Google 3P Authorization JavaScript Library.");
			})), o.src = s.library, o.async = !0, o.defer = !0, document.head.appendChild(o);
		}
	} else t(s.ssrError);
})), w = (e) => {
	f.apiLoadIntitited ? f.apiLoaded ? e(window.google) : watch((() => f.apiLoaded), ((t) => {
		t && e(window.google);
	})) : h().then(((t) => {
		e(t);
	})).catch(((e$1) => {
		throw e$1;
	}));
}, m = (e, t, o, i) => {
	if (!e.client_id) throw new Error("Prop client id required since plugin is not initialized with a client id");
	w((() => {
		((e$1, t$1, o$1, i$1, n) => {
			if (n) {
				const t$2 = e$1.callback;
				e$1.callback = (e$2) => {
					e$2.credential ? t$2 && t$2(e$2) : n(e$2);
				};
			}
			window.google.accounts.id.initialize(e$1);
			const l = t$1.value;
			l && !i$1 && window.google.accounts.id.renderButton(l, o$1);
		})(e, t, o.buttonConfig, i, o.error), o.prompt && y({
			clientId: o.clientId,
			callback: o.callback,
			error: o.error,
			autoLogin: o.autoLogin
		});
	}));
}, I = (e) => new Promise(((t, o) => {
	w(((i) => {
		if (!(e && e.clientId || g.clientId)) throw new Error("clientId is required since the plugin is not initialized with a Client Id");
		i.accounts.oauth2.initCodeClient({
			client_id: e && e.clientId || g.clientId || "",
			scope: s.scopes,
			ux_mode: "popup",
			callback: (e$1) => {
				e$1.code ? t(e$1) : o(e$1);
			},
			error_callback: (e$1) => {
				o(e$1);
			}
		}).requestCode();
	}));
})), _ = (e) => new Promise(((t, o) => {
	w(((i) => {
		if (!(e && e.clientId || g.clientId)) throw new Error("clientId is required since the plugin is not initialized with a Client Id");
		i.accounts.oauth2.initTokenClient({
			client_id: e && e.clientId || g.clientId || "",
			scope: s.scopes,
			callback: (e$1) => {
				e$1.access_token ? t(e$1) : o(e$1);
			},
			error_callback: (e$1) => {
				o(e$1);
			}
		}).requestAccessToken();
	}));
})), y = (e) => {
	if (!e && (e = {}), !e.clientId && !g.clientId) throw new Error("clientId is required");
	const t = { use_fedcm_for_prompt: !0 };
	return e.clientId && (t.client_id = e.clientId), !e.clientId && g.clientId && (t.client_id = g.clientId), e.context && (t.context = e.context), null != e.autoLogin && (t.auto_select = e.autoLogin), null != e.cancelOnTapOutside && (t.cancel_on_tap_outside = e.cancelOnTapOutside), new Promise(((o, i) => {
		t.callback = (t$1) => {
			e && e.callback && e.callback(t$1), t$1.credential ? o(t$1) : i(t$1);
		}, w(((e$1) => {
			e$1.accounts.id.initialize(t), e$1.accounts.id.prompt();
		}));
	}));
}, k = () => {
	w(((e) => {
		e.accounts.id.disableAutoSelect();
	}));
};
var C = defineComponent({
	__name: "GoogleLogin",
	props: {
		clientId: {
			type: String,
			required: !1
		},
		prompt: {
			type: Boolean,
			required: !1,
			default: !1
		},
		autoLogin: {
			type: Boolean,
			required: !1,
			default: !1
		},
		popupType: {
			type: String,
			required: !1
		},
		idConfiguration: {
			type: Object,
			required: !1
		},
		buttonConfig: {
			type: Object,
			required: !1
		},
		callback: {
			type: Function,
			required: !1
		},
		error: {
			type: Function,
			required: !1
		}
	},
	setup(e) {
		if (!("undefined" != typeof window)) throw new Error(s.ssrError);
		const t = !!useSlots().default, o = e, u$1 = ((e$1, t$1) => {
			const o$1 = { ...e$1 };
			for (const e$2 in t$1) void 0 !== t$1[e$2] && null !== t$1[e$2] && (o$1[e$2] = t$1[e$2]);
			return o$1;
		})(g, o), f$1 = {
			client_id: u$1.clientId || null,
			auto_select: u$1.autoLogin || !1,
			callback: u$1.callback,
			...u$1.idConfiguration
		}, b$1 = ref();
		return onMounted((() => {
			m(f$1, b$1, u$1, t), o.popupType && !t && console.warn("Option 'popupType' is ignored since a slot which act as a custom login button was not found!!!");
		})), (e$1, o$1) => (openBlock(), createElementBlock("div", {
			class: "g-btn-wrapper",
			onClick: o$1[0] || (o$1[0] = (e$2) => unref(t) && void ("TOKEN" === unref(u$1).popupType ? _({ clientId: u$1.clientId }).then(((e$3) => {
				u$1.callback && u$1.callback(e$3);
			})).catch(((e$3) => {
				u$1.error && u$1.error(e$3);
			})) : I({ clientId: u$1.clientId }).then(((e$3) => {
				u$1.callback && u$1.callback(e$3);
			})).catch(((e$3) => {
				u$1.error && u$1.error(e$3);
			}))))
		}, [unref(t) ? createCommentVNode("v-if", !0) : (openBlock(), createElementBlock("span", {
			key: 0,
			ref_key: "buttonRef",
			ref: b$1,
			class: "g-btn"
		}, null, 512)), renderSlot(e$1.$slots, "default")]));
	}
});
(function(e, t) {
	void 0 === t && (t = {});
	var o = t.insertAt;
	if (e && "undefined" != typeof document) {
		var i = document.head || document.getElementsByTagName("head")[0], n = document.createElement("style");
		n.type = "text/css", "top" === o && i.firstChild ? i.insertBefore(n, i.firstChild) : i.appendChild(n), n.styleSheet ? n.styleSheet.cssText = e : n.appendChild(document.createTextNode(e));
	}
})("\n.g-btn-wrapper[data-v-5e610566] {\n  display: inline-block;\n}\n"), C.__scopeId = "data-v-5e610566", C.__file = "src/plugin/GoogleLogin.vue";
var L = { install: (e, t) => {
	t && ((e$1) => {
		e$1.clientId && (g.clientId = e$1.clientId), e$1.popupType && (g.popupType = e$1.popupType), null != e$1.prompt && (g.prompt = e$1.prompt), null != e$1.autoLogin && (g.autoLogin = e$1.autoLogin), e$1.idConfiguration && (g.idConfiguration = e$1.idConfiguration), e$1.buttonConfig && (g.buttonConfig = e$1.buttonConfig), e$1.callback && (g.callback = e$1.callback);
	})(t), h().then((() => {
		if (t.clientId) {
			const e$1 = {
				client_id: t.clientId,
				auto_select: !0 === t.autoLogin,
				callback: t.callback,
				use_fedcm_for_prompt: !0,
				...t.idConfiguration
			};
			window.google.accounts.id.initialize(e$1), t.prompt && window.google.accounts.id.prompt();
		}
	})).catch(((e$1) => {
		if (!t.error) throw e$1;
		t.error(e$1);
	})), e.component("GoogleLogin", C);
} };

//#endregion
export { u as CallbackTypes, C as GoogleLogin, b as decodeCredential, L as default, I as googleAuthCodeLogin, k as googleLogout, y as googleOneTap, w as googleSdkLoaded, _ as googleTokenLogin };
//# sourceMappingURL=vue3-google-login.js.map